/* Universal reset for all elements */
*,
*::before,
*::after {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Body and html reset */
html, body {
  height: 100%;
  width: 100%;
  overflow: hidden;
  box-sizing: border-box;
  background-color: var(--background-color);
  color: var(--primary-font-color);
  /* font-family set via :root or specific elements */
}

/* Root variables for styling */
:root {
  --background-color: #FBF5E9;
  --primary-font-color: #231F20;
  --primary-font-color-overlap: var(--background-color);
  --primary-font-family: serif, "neue-haas-unica", helvetica, sans-serif;
  --primary-font-size: 1.1em;
  --primary-font-weight: 400;
  --secondary-font-size: .9em;
  --secondary-font-weight: 400;
  --video-border-radius: 0em;
}

/* TITLE */
.title {
  font-family: var(--primary-font-family);
  font-size: var(--primary-font-size);
  font-weight: var(--primary-font-weight);
  background-color: transparent;
  display: inline;
  border: none;
  padding: 0;
}

.info {
  font-family: var(--primary-font-family);
  font-size: var(--secondary-font-size);
  font-weight: var(--secondary-font-weight);
  background-color: transparent;
  display: inline;
  border: none;
  padding: 0;
}

.intro-title.overlapped {
  color: var(--primary-font-color-overlap);
  opacity: 65%;
}

/* --- Page Container --- */
.page-container {
  display: flex;
  height: 100vh;
  width: 100vw;
  overflow: hidden;
}

/* --- Columns --- */
.left-column, .right-column {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  height: 100%;
  position: relative; /* Ensure they stack above middle if needed */
  z-index: 5;
}

.middle-column {
  flex: 3;
  height: 100%;
  overflow: hidden; /* CRUCIAL */
  position: relative;
}

/* --- Video Track (Animated by GSAP) --- */
.video-track {
  width: 100%;
  height: 100%; /* Track fills middle column */
  position: relative; /* Contains the scroll items */
  will-change: transform; /* Optimize animation */
}

/* --- SCROLL ITEM (Common class for Videos and Info) --- */
.scroll-item { /* <<< CORRECTED SELECTOR */
  width: 100%;
  height: 100vh; /* Each item is full viewport height */
  position: relative; /* Stays in flow, allows absolute children */
  overflow: hidden;
  /* flex-shrink: 0; */ /* Only needed if .video-track is display:flex */
}

/* --- Video Item Specific --- */
.video-item {
  /* Inherits from .scroll-item */
  /* Keep your centering */
  display: flex;
  align-items: center;
  justify-content: center;
}

/* --- Aspect Wrapper --- */
.video-aspect-wrapper {
  position: relative; /* Your original choice - children are positioned relative to this */
  width: 100%;
  /* Height determined by aspect-ratio JS */
  max-width: 100%; /* Usually redundant */
  max-height: 100%; /* Prevent exceeding parent height */
  overflow: hidden;
  background-color: #111; /* Optional dark bg during load */
}

/* --- Thumbnail --- */
.video-thumbnail {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  z-index: 2; /* Above iframe */
  pointer-events: none;
  opacity: 1;
  visibility: visible;
  transition: opacity 0.4s ease-in-out, visibility 0s linear 0s; /* Corrected transition */
  /* background-color: #ffd60a; */
}

.video-thumbnail.thumbnail-hidden {
  opacity: 0;
  visibility: hidden;
  z-index: 0; /* Go behind */
  /* Adjust delay for visibility */
  transition: opacity 0.4s ease-in-out, visibility 0s linear 0.4s;
}

/* --- Iframe --- */
/* USING ONLY ABSOLUTE POSITIONING relative to video-aspect-wrapper */
.video-aspect-wrapper iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: block;
  border: none;
  z-index: 1; /* Below thumbnail initially */
  pointer-events: none;
}

/* --- Video Controls --- */
.video-controls { /* Simplified selector */
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease-in-out, visibility 0s linear 0.3s; /* Visibility delay */
  position: absolute;
  bottom: 15px; /* Your original spacing */
  left: 50%;
  transform: translateX(-50%);
  z-index: 3; /* Above thumbnail and iframe */
  background: rgba(0, 0, 0, 0.6);
  padding: 5px 10px; /* Your original padding */
  border-radius: 5px;
  display: flex;
  gap: 10px; /* Your original gap */
  align-items: center;
  pointer-events: none; /* Initially not interactive */
}

/* Show controls on hover of the ASPECT WRAPPER */
.video-aspect-wrapper:hover .video-controls {
  opacity: 1;
  visibility: visible;
  pointer-events: auto; /* Enable interaction */
  transition-delay: 0s; /* Ensure visibility appears instantly */
}

.controls-button { /* Simplified selector */
  background: none;
  border: 1px solid white; /* Your original border */
  color: white;
  padding: 5px 10px; /* Your original padding */
  cursor: pointer;
  font-size: inherit; /* Inherit font size */
}

.controls-button:hover {
  background-color: rgba(255, 255, 255, 0.2); /* Your original hover */
}


/* --- Info Section Specific Styles --- */
.info-section {
    /* Inherits width, height, position, overflow from .scroll-item */
    background-color: var(--background-color);
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 40px;
    color: var(--primary-font-color);
}

.info-content {
    max-width: 800px; /* Adjust as needed */
    text-align: center; /* Or left */
}

.info-content h2 {
    margin-bottom: 20px;
    /* Add font styles if needed */
}
.info-content p {
    margin-bottom: 1em;
    line-height: 1.6;
     /* Add font styles if needed */
}

/* --- Active Scroll Item Style --- */
/* REMEMBER to update JS: item?.classList.toggle('active-scroll-item', ...) */
.scroll-item.active-scroll-item {
  /* Add any visual indication that this is the active section */
  /* Example:
  outline: 2px solid navy;
  outline-offset: -2px;
   */
}

// scroll.js (MODIFIED FOR INFO SECTION - PART 1)

/**
 * Throttles a function to ensure it's called at most once within a specified limit.
 */
function throttle(func, limit) {
    let inThrottle;
    return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => {
                 inThrottle = false;
            }, limit);
        }
    }
}

// --- State Variables ---
let currentIndex = 0;
let scrollItems = []; // MODIFIED: Holds all items (videos + info)
let videoTrack = null;
let isAnimating = false;

// --- Configuration Variables ---
let animationDuration;
let throttleInterval;

// --- Video Control Variables ---
// This still holds ONLY the actual Video class instances passed from playlist.js
let controlledVideos = [];

// --- Global Volume State ---
let globalVolumeLevel = 0.0; // Start muted
const DEFAULT_UNMUTE_LEVEL = 0.6; // Volume when unmuting (0.0 to 1.0)

/**
 * Animates or sets the video track to a specific index AND controls video playback/state.
 * @param {number} index - The target index (0 to scrollItems.length - 1).
 * @param {boolean} [immediate=false] - If true, set position instantly without animation.
 */
function goToIndex(index, immediate = false) {
    // --- MODIFIED: Use scrollItems for boundary checks ---
    if (!videoTrack || !scrollItems || scrollItems.length === 0) {
         console.error("goToIndex aborted: videoTrack or scrollItems missing.");
         return;
    }
    if (index < 0 || index >= scrollItems.length) { // Use scrollItems.length
         console.warn(`goToIndex aborted: Index ${index} out of bounds (0-${scrollItems.length - 1}).`);
         return;
    }
    // --- END MODIFICATION ---

    // Prevent stacking animations (if not immediate)
    if (isAnimating && !immediate) {
        console.log(`goToIndex aborted: Animation already in progress.`);
        return;
    }

    const previousIndex = currentIndex; // Store index we are scrolling FROM

    // Prevent redundant calls if index hasn't changed (allow if immediate)
    if (index === previousIndex && !immediate) {
        // console.log(`[goToIndex] Already at index ${index}.`); // Optional log
        return;
    }

    isAnimating = true; // Set flag BEFORE animation/set starts
    currentIndex = index; // Update currentIndex
    console.log(`goToIndex: Updated currentIndex to ${currentIndex}. Previous was ${previousIndex}`);
    updateActiveClass(); // Update active class for the new item

    const targetYPercent = -currentIndex * 100;

    // Perform Scroll Action
    if (immediate) {
        gsap.set(videoTrack, { yPercent: targetYPercent });
        isAnimating = false;
        // updateActiveClass(); // Already called above
        // Call the async function but don't wait for it here. Handle errors.
        controlVideoPlayback(currentIndex, previousIndex).catch(err => {
             console.error("[goToIndex Immediate] Error controlling video playback:", err);
        });
    } else {
        gsap.to(videoTrack, {
            yPercent: targetYPercent,
            duration: animationDuration,
            ease: "back.out(.5)", // Or your preferred ease
            overwrite: "auto",
            onComplete: () => {
                console.log(`[goToIndex Animation COMPLETE] Target index: ${currentIndex}. Setting isAnimating = false.`);
                 // --- SET FLAG TO FALSE *BEFORE* potentially long async call ---
                isAnimating = false;
                // updateActiveClass(); // Already called above
                 // Call the async function but don't wait for it here. Handle errors.
                controlVideoPlayback(currentIndex, previousIndex).catch(err => {
                    console.error("[goToIndex Animation] Error controlling video playback onComplete:", err);
                });
            },
            onInterrupt: () => {
                 console.warn(`[goToIndex Animation INTERRUPTED] Targeting index ${currentIndex}. Setting isAnimating = false.`);
                 // --- Ensure flag is reset on interrupt ---
                 isAnimating = false;
            }
        });
    }
}

/**
 * Updates the 'active-scroll-item' class on scrollable items based on currentIndex.
 */
function updateActiveClass() {
     // --- MODIFIED: Use scrollItems and new class name ---
     if (!scrollItems || scrollItems.length === 0) return;
     scrollItems.forEach((item, i) => {
        item?.classList.toggle('active-scroll-item', i === currentIndex); // Use new class name
    });
     // --- END MODIFICATION ---
}

/**
 * Detects if the current device supports touch events.
 */
function detectTouchDevice() {
    // ... (no changes needed here) ...
    let hasTouch = false; if ('maxTouchPoints' in navigator) hasTouch = navigator.maxTouchPoints > 0; else if ('ontouchstart' in window) hasTouch = true; else if ('msMaxTouchPoints' in navigator) hasTouch = navigator.msMaxTouchPoints > 0; return hasTouch;
}

// --- Throttled Scroll Handler (defined later) ---
let handleThrottledScroll = null;

/**
 * Initializes GSAP scroll functionality, sets up event listeners, and initial state.
 * @param {Array<Video>} videos - The array of Video objects from playlist.js.
 */
export function initializeGsapScroll(videos) {
    controlledVideos = videos; // Store the actual video objects separately
    // Log message updated later after finding scrollItems

    globalVolumeLevel = 0.0; // Ensure starting muted
    const isTouchDevice = detectTouchDevice();

    // Conditional Timings (adjust as needed)
    const DESKTOP_ANIMATION_DURATION = 1.0; // Example
    const MOBILE_ANIMATION_DURATION = 0.7;  // Example
    const DESKTOP_THROTTLE_INTERVAL = 200;  // Example - adjust responsiveness
    const MOBILE_THROTTLE_INTERVAL = 200;
    animationDuration = isTouchDevice ? MOBILE_ANIMATION_DURATION : DESKTOP_ANIMATION_DURATION;
    throttleInterval = isTouchDevice ? MOBILE_THROTTLE_INTERVAL : DESKTOP_THROTTLE_INTERVAL;

    // Find DOM Elements
    videoTrack = document.querySelector(".js-video-track");
    if (!videoTrack) { console.error("Scroll Init Failed: '.js-video-track' not found."); return; }

    // --- MODIFIED: Select ALL items with the common class ---
    scrollItems = gsap.utils.toArray(videoTrack.children).filter(el => el.classList.contains('scroll-item'));
    if (scrollItems.length === 0) {
        console.error("Scroll Init Failed: No '.scroll-item' children found in track.");
        return;
    }
    console.log(`Found ${scrollItems.length} total scroll items (videos + info).`);
    // --- END MODIFICATION ---

    // --- MODIFIED: Update log message ---
    console.log("GSAP Scroll Initializing with", controlledVideos.length, "videos and", scrollItems.length, "total scroll items.");
    // --- END MODIFICATION ---


    // Define Throttled Scroll Handler (using scrollItems.length)
    handleThrottledScroll = throttle((delta) => {
        // isAnimating check was REMOVED from here in previous step
        let newIndex = currentIndex;
        // Use simple positive/negative check, check boundaries with scrollItems.length
        if (delta > 0 && currentIndex < scrollItems.length - 1) { // Scroll Down/Next
            newIndex++;
        } else if (delta < 0 && currentIndex > 0) { // Scroll Up/Previous
            newIndex--;
        } else {
             return; // No change or boundary
        }

        if (newIndex !== currentIndex) {
            // console.log(`[Throttle Inner] Calling goToIndex(${newIndex})`);
            goToIndex(newIndex); // Let goToIndex handle isAnimating check
        }
    }, throttleInterval);


    // Reset State
    currentIndex = 0;
    isAnimating = false;

// CONTINUE TO PART 2...