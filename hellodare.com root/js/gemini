// scroll.js (REORGANIZED VERSION)

// ==================================================
// IMPORTS (If any needed FROM other modules)
// ==================================================
// (Currently none needed)


// ==================================================
// MODULE STATE VARIABLES
// ==================================================
let currentIndex = 0;
let scrollItems = []; // All scrollable DOM elements
let videoTrack = null;
let isAnimating = false;
let controlledVideos = []; // Actual Video class instances
let globalVolumeLevel = 0.0; // Start muted

// Configuration (set during initialization)
let animationDuration = 1.0; // Default values
let throttleInterval = 200;  // Default values

// --- Throttled Scroll Handler (declared here, defined in init) ---
let scrollInputHandler = null; // Renamed for clarity


// ==================================================
// CORE SCROLL & ANIMATION LOGIC
// ==================================================

/**
 * Updates the 'active-scroll-item' class on scrollable items based on currentIndex.
 */
function updateActiveClass() {
     if (!scrollItems || scrollItems.length === 0) return;
     scrollItems.forEach((item, i) => {
        item?.classList.toggle('active-scroll-item', i === currentIndex);
    });
}

/**
 * Main function to scroll to a specific index.
 * Handles animation, state flags, and triggers video control.
 * Exported for use by button listeners.
 * @param {number} index - The target index (0 to scrollItems.length - 1).
 * @param {boolean} [immediate=false] - If true, set position instantly.
 */
export function goToIndex(index, immediate = false) {
    // Boundary checks
    if (!videoTrack || !scrollItems || scrollItems.length === 0) { console.error("goToIndex aborted: videoTrack or scrollItems missing."); return; }
    if (index < 0 || index >= scrollItems.length) { console.warn(`goToIndex aborted: Index ${index} out of bounds (0-${scrollItems.length - 1}).`); return; }

    // Prevent stacking animations
    if (isAnimating && !immediate) { console.log(`goToIndex aborted: Animation already in progress.`); return; }

    const previousIndex = currentIndex;
    if (index === previousIndex && !immediate) { return; } // No change

    // Update state
    isAnimating = !immediate; // Set true only if animating
    currentIndex = index;
    console.log(`goToIndex: Updated currentIndex to ${currentIndex}. Previous was ${previousIndex}`);
    updateActiveClass(); // Update visual indicator

    // Trigger playback control attempt IMMEDIATELY
    controlVideoPlayback(currentIndex, previousIndex).catch(err => {
        console.error("[goToIndex Direct Call] Error controlling video playback:", err);
    });

    const targetYPercent = -currentIndex * 100;

    // Perform Scroll Animation / Set
    if (immediate) {
        gsap.set(videoTrack, { yPercent: targetYPercent });
        // isAnimating remains false
        console.log(`[goToIndex Immediate Set] Target index: ${currentIndex}.`);
    } else {
        gsap.to(videoTrack, {
            yPercent: targetYPercent,
            duration: animationDuration,
            ease: "back.out(.5)",
            overwrite: "auto",
            onComplete: () => {
                // console.log(`[goToIndex Animation COMPLETE] Target index: ${currentIndex}.`);
                isAnimating = false; // Reset flag only on completion
            },
            onInterrupt: () => {
                 // console.warn(`[goToIndex Animation INTERRUPTED] Targeting index ${currentIndex}.`);
                 isAnimating = false; // Ensure reset
            }
        });
    }
}


// ==================================================
// VIDEO PLAYBACK & VOLUME CONTROL
// ==================================================

/**
 * Controls play/pause/volume for videos based on scroll index activation.
 * Aware of the Info Section. Logic based on your working version.
 * @param {number} currentIdx - The index of the item to activate.
 * @param {number} previousIdx - The index of the item being deactivated.
 */
async function controlVideoPlayback(currentIdx, previousIdx) {
    if (!scrollItems || scrollItems.length === 0) return;
    // console.log(`--- [Async Play Once Logic] Controlling Playback: Activate=${currentIdx} ---`);

    // Iterate through actual video indices
    for (let index = 0; index < controlledVideos.length; index++) {
        const video = controlledVideos[index];
        if (!video) continue;

        const playPauseButton = document.getElementById(`playPauseButton-${video.id}`);
        const soundButton = document.getElementById(`soundButton-${video.id}`);

        // Action for the VIDEO AT INDEX 'index'
        if (index === currentIdx) { // If this video is the one being activated
            try {
                const player = await video.initializePlayer();
                // Check hasPlayedOnce logic (or justFinishedLoopLimit if using that)
                if (video.hasPlayedOnce) { // Assuming this flag is correctly managed in Video.js
                     console.log(`%c[ControlVid ${video.id}] Activate Play SKIPPED: hasPlayedOnce is TRUE. Ensuring pause.`, "color: blue; font-weight: bold;");
                     if (playPauseButton) playPauseButton.innerText = 'Play';
                     if (video.thumbnailElement) video.thumbnailElement.classList.remove('thumbnail-hidden');
                     await player.pause().catch(e=>{/* ignore */}); // Ensure paused
                } else {
                    // Activate normally
                    // console.log(`[ControlVid ${video.id}] Activating Video (Index ${index}). Setting volume & playing...`);
                    await player.setVolume(globalVolumeLevel);
                    await player.play();
                    if (playPauseButton) playPauseButton.innerText = 'Pause';
                }
                 if (soundButton) soundButton.innerText = globalVolumeLevel > 0 ? 'Sound On' : 'Sound Off'; // Always update sound btn
            } catch (error) {
                console.warn(`[ControlVid ${video?.id || 'N/A'}] Error activating video (Index ${index}): ${error.message}`);
                if (playPauseButton) playPauseButton.innerText = 'Play';
                if (soundButton) soundButton.innerText = globalVolumeLevel > 0 ? 'Sound On' : 'Sound Off';
            }
        } else { // If this video index is NOT the one being activated
             // Pause inactive videos
             if (soundButton) soundButton.innerText = globalVolumeLevel > 0 ? 'Sound On' : 'Sound Off';
             if (video.player) {
                try {
                    video.player.pause().catch(e => {/* ignore non-critical pause error */});
                    if (playPauseButton) playPauseButton.innerText = 'Play';
                } catch (syncError) { if (playPauseButton) playPauseButton.innerText = 'Play'; }
             } else {
                 if (playPauseButton) playPauseButton.innerText = 'Play';
             }
        }
    } // End video loop

    // Handle Info Section Activation (ensure videos paused)
    if (currentIdx >= controlledVideos.length) {
         // console.log(`[ControlVid] Info Section Activated (Index ${currentIdx}). Ensuring all videos paused.`);
         for (const vidToPause of controlledVideos) {
             const btn = document.getElementById(`playPauseButton-${vidToPause?.id}`);
             if (vidToPause && vidToPause.player) { vidToPause.player.pause().catch(e => {}); }
             if(btn) btn.innerText = 'Play';
         }
    }
    // console.log(`--- [Async Play Once Logic] Finished Controlling Playback ---`);
}

/**
 * Helper function to apply the current globalVolumeLevel to all video players.
 */
async function applyGlobalVolume() {
     // console.log(`[Async] Applying global volume ${globalVolumeLevel.toFixed(2)}.`);
     for (const video of controlledVideos) { // Only iterate actual videos
         const soundButton = document.getElementById(`soundButton-${video.id}`);
         try {
             const player = await video.initializePlayer();
             await player.setVolume(globalVolumeLevel);
             if (soundButton) soundButton.innerText = globalVolumeLevel > 0 ? 'Sound On' : 'Sound Off';
         } catch (error) {
             // console.warn(`[ApplyVol ${video.id}] Failed: ${error.message}`);
             if (soundButton) soundButton.innerText = globalVolumeLevel > 0 ? 'Sound On' : 'Sound Off'; // Update button anyway
         }
    }
}

/**
 * Adjusts the global volume level and applies it.
 */
async function adjustGlobalVolume(delta) {
    const DEFAULT_UNMUTE_LEVEL = 0.6; // Keep constant here
    let newVolume = globalVolumeLevel + delta;
    newVolume = Math.max(0, Math.min(1, newVolume));
    if (newVolume.toFixed(2) === globalVolumeLevel.toFixed(2)) return;
    // console.log(`[Async] Adjusting global volume: ${globalVolumeLevel.toFixed(2)} -> ${newVolume.toFixed(2)}`);
    globalVolumeLevel = newVolume;
    await applyGlobalVolume(); // Use helper
}

/**
 * Toggles the global volume between muted (0) and a default level.
 * EXPORTED for use by button listeners.
 */
export async function toggleGlobalVolume() {
    const DEFAULT_UNMUTE_LEVEL = 0.6; // Keep constant here
    const newVolume = (globalVolumeLevel > 0) ? 0.0 : DEFAULT_UNMUTE_LEVEL;
    // console.log(`[Async] Toggling global volume -> ${newVolume.toFixed(2)}`);
    globalVolumeLevel = newVolume;
    await applyGlobalVolume(); // Use helper
}


// ==================================================
// INPUT EVENT HANDLERS & SETUP
// ==================================================

/** Handles keyboard events. */
async function handleKeyDown(event) {
    const targetTagName = event.target.tagName;
    if (targetTagName === 'INPUT' || targetTagName === 'TEXTAREA' || event.target.isContentEditable) return;
    if (!scrollItems || scrollItems.length === 0) return; // Use scrollItems for general check

    const activeVideo = (currentIndex < controlledVideos.length) ? controlledVideos[currentIndex] : null;

    switch (event.key) {
        case ' ': case 'Spacebar':
            event.preventDefault();
            if (activeVideo) {
                const btn = document.getElementById(`playPauseButton-${activeVideo.id}`);
                if (btn) try { await activeVideo.togglePlayPause(btn); } catch (e) { console.error(e); }
                else console.warn("Spacebar: Btn not found");
            } else console.log("Spacebar ignored: Info section active.");
            break;
        case 'ArrowLeft': case 'ArrowUp':
            event.preventDefault();
            if (scrollInputHandler) scrollInputHandler(-1); // Use the handler variable
            break;
        case 'ArrowRight': case 'ArrowDown':
            event.preventDefault();
            if (scrollInputHandler) scrollInputHandler(1); // Use the handler variable
            break;
        case 'AudioVolumeUp': case '+': // Example key binding
            event.preventDefault();
            await adjustGlobalVolume(0.1);
            break;
        case 'AudioVolumeDown': case '-': // Example key binding
            event.preventDefault();
            await adjustGlobalVolume(-0.1);
            break;
    }
}

/** Handles wheel events. */
function handleWheel(event) {
    event.preventDefault();
    if (scrollInputHandler) scrollInputHandler(event.deltaY); // Use the handler variable
}

/** Creates and returns touch event handlers using a closure. */
function createTouchHandlers() {
    let touchStartY = null, touchStartX = null;
    const minSwipeDistanceY = 30, maxSwipeDistanceX = 100; // Adjust sensitivity

    function onTouchStart(event) {
        if (event.touches.length === 1) { touchStartY = event.touches[0].clientY; touchStartX = event.touches[0].clientX; }
        else { touchStartY = null; touchStartX = null; }
    }
    function onTouchMove(event) {
        if (touchStartY !== null) { const tX=event.touches[0].clientX; if (Math.abs(touchStartX-tX)<maxSwipeDistanceX) { event.preventDefault(); } }
    }
    function onTouchEnd(event) {
        if (touchStartY === null) return;
        const tY = event.changedTouches[0].clientY; const tX = event.changedTouches[0].clientX;
        const dY = touchStartY - tY; const dX = Math.abs(touchStartX - tX);
        if (Math.abs(dY) > minSwipeDistanceY && dX < maxSwipeDistanceX) {
            if (scrollInputHandler) scrollInputHandler(dY); // Use the handler variable
        }
        touchStartY = null; touchStartX = null; // Reset
    }
    return { onTouchStart, onTouchMove, onTouchEnd };
}

/** Creates and returns a resize handler using a closure for timeout. */
function createResizeHandler() {
    let resizeTimeout;
    function onResize() {
         clearTimeout(resizeTimeout);
         resizeTimeout = setTimeout(() => {
             // console.log("Resize handler: Repositioning.");
             goToIndex(currentIndex, true); // Snap immediately
         }, 250); // Debounce resize calls
    }
    return onResize;
}

/** Attaches all necessary global event listeners. */
function attachEventListeners(touchHandlers, resizeHandler) {
    // Detach existing listeners first to prevent duplicates
    window.removeEventListener('keydown', handleKeyDown);
    window.removeEventListener('wheel', handleWheel);
    window.removeEventListener('touchstart', touchHandlers.onTouchStart);
    window.removeEventListener('touchmove', touchHandlers.onTouchMove);
    window.removeEventListener('touchend', touchHandlers.onTouchEnd);
    window.removeEventListener('resize', resizeHandler);

    // Attach new listeners
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('wheel', handleWheel, { passive: false });
    window.addEventListener('touchstart', touchHandlers.onTouchStart, { passive: true });
    window.addEventListener('touchmove', touchHandlers.onTouchMove, { passive: false });
    window.addEventListener('touchend', touchHandlers.onTouchEnd, { passive: true });
    window.addEventListener('resize', resizeHandler);
}


// ==================================================
// UTILITY FUNCTIONS
// ==================================================

/** Throttles a function execution. */
function throttle(func, limit) {
    let inThrottle;
    return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => { inThrottle = false; }, limit);
        }
    }
}

/** Detects touch capability. */
function detectTouchDevice() {
    let hasTouch = false; if ('maxTouchPoints' in navigator) hasTouch = navigator.maxTouchPoints > 0; else if ('ontouchstart' in window) hasTouch = true; else if ('msMaxTouchPoints' in navigator) hasTouch = navigator.msMaxTouchPoints > 0; return hasTouch;
}


// ==================================================
// INITIALIZATION FUNCTION (EXPORTED)
// ==================================================

/**
 * Initializes GSAP scroll functionality, sets up state, and attaches listeners.
 * @param {Array<Video>} videos - The array of Video class instances.
 */
export function initializeGsapScroll(videos) {
    controlledVideos = videos; // Store video instances

    // Find DOM Elements
    videoTrack = document.querySelector(".js-video-track");
    if (!videoTrack) { console.error("Scroll Init Failed: '.js-video-track' not found."); return; }
    scrollItems = gsap.utils.toArray(videoTrack.children).filter(el => el.classList.contains('scroll-item'));
    if (scrollItems.length === 0) { console.error("Scroll Init Failed: No '.scroll-item' children found."); return; }
    console.log(`GSAP Scroll Initializing with ${controlledVideos.length} videos and ${scrollItems.length} total items.`);

    // Determine Config
    const isTouchDevice = detectTouchDevice();
    const DESKTOP_ANIMATION_DURATION = 1.0;
    const MOBILE_ANIMATION_DURATION = 0.7;
    const DESKTOP_THROTTLE_INTERVAL = 200;
    const MOBILE_THROTTLE_INTERVAL = 200;
    animationDuration = isTouchDevice ? MOBILE_ANIMATION_DURATION : DESKTOP_ANIMATION_DURATION;
    throttleInterval = isTouchDevice ? MOBILE_THROTTLE_INTERVAL : DESKTOP_THROTTLE_INTERVAL;

    // Define the core scroll input processing function
    const processScrollInput = (delta) => {
        let newIndex = currentIndex;
        if (delta > 0 && currentIndex < scrollItems.length - 1) { newIndex++; }
        else if (delta < 0 && currentIndex > 0) { newIndex--; }
        else { return; } // No change or boundary

        if (newIndex !== currentIndex) {
            goToIndex(newIndex); // Call the main scroll function
        }
    };

    // Create the throttled handler
    scrollInputHandler = throttle(processScrollInput, throttleInterval);

    // Reset State
    currentIndex = 0;
    isAnimating = false;
    globalVolumeLevel = 0.0; // Start muted

    // Create handlers that manage their own state (like timeouts/touch coords)
    const touchHandlers = createTouchHandlers();
    const resizeHandler = createResizeHandler();

    // Set Initial Position & State
    goToIndex(0, true);

    // Attach Global Event Listeners using the created handlers
    attachEventListeners(touchHandlers, resizeHandler);

    console.log("GSAP Scroll Initialization complete. Listeners active.");
} // === END of initializeGsapScroll ===